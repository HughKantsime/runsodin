"""Unit tests for backend/print_file_meta.py.

These tests run without a DB or running server — pure module logic.
"""
import io
import os
import sys
import tempfile
import zipfile

import pytest

# Add backend directory to path so we can import the module directly
sys.path.insert(0, os.path.join(os.path.dirname(__file__), "..", "backend"))

import modules.models_library.print_file_meta as pfm


# ─────────────────────────────────────────────
# Helpers
# ─────────────────────────────────────────────

def _write_gcode(lines):
    """Write lines to a temp .gcode file and return its path."""
    with tempfile.NamedTemporaryFile(
        mode="w", suffix=".gcode", delete=False, encoding="utf-8"
    ) as f:
        f.write("\n".join(lines))
        return f.name


def _write_3mf(files: dict):
    """Create a minimal .3mf zip with given filename→content mapping.

    Returns the temp file path.
    """
    with tempfile.NamedTemporaryFile(suffix=".3mf", delete=False) as f:
        path = f.name

    with zipfile.ZipFile(path, "w") as zf:
        for name, content in files.items():
            if isinstance(content, str):
                content = content.encode("utf-8")
            zf.writestr(name, content)

    return path


# ─────────────────────────────────────────────
# _resolve_api_types
# ─────────────────────────────────────────────

def test_resolve_api_types_3mf():
    assert pfm._resolve_api_types(".3mf") == "bambu"


def test_resolve_api_types_gcode():
    result = pfm._resolve_api_types(".gcode")
    assert result == "moonraker,prusalink,elegoo"


def test_resolve_api_types_bgcode():
    result = pfm._resolve_api_types(".bgcode")
    assert result == "moonraker,prusalink,elegoo"


def test_resolve_api_types_unknown():
    result = pfm._resolve_api_types(".xyz")
    assert result == ""


# ─────────────────────────────────────────────
# _extract_gcode_meta — PrusaSlicer
# ─────────────────────────────────────────────

def test_gcode_prusa_bed_size():
    path = _write_gcode([
        "; generated by PrusaSlicer",
        "; bed_size_x = 250.00",
        "; bed_size_y = 210.00",
        "G28",
    ])
    try:
        x, y = pfm._extract_gcode_meta(path)
        assert x == 250.0
        assert y == 210.0
    finally:
        os.unlink(path)


def test_gcode_prusa_bed_size_350():
    path = _write_gcode([
        "; bed_size_x = 350.00",
        "; bed_size_y = 350.00",
    ])
    try:
        x, y = pfm._extract_gcode_meta(path)
        assert x == 350.0
        assert y == 350.0
    finally:
        os.unlink(path)


# ─────────────────────────────────────────────
# _extract_gcode_meta — Cura
# ─────────────────────────────────────────────

def test_gcode_cura_machine_width_depth():
    path = _write_gcode([
        ";Generated with Cura_SteamEngine 5.6.0",
        "; machine_width = 220",
        "; machine_depth = 220",
    ])
    try:
        x, y = pfm._extract_gcode_meta(path)
        assert x == 220.0
        assert y == 220.0
    finally:
        os.unlink(path)


# ─────────────────────────────────────────────
# _extract_gcode_meta — Bambu gcode
# ─────────────────────────────────────────────

def test_gcode_bambu_plate_x():
    path = _write_gcode([
        "; plate_x = 256",
        "; plate_y = 256",  # not parsed, but shouldn't break anything
        "G28",
    ])
    try:
        x, y = pfm._extract_gcode_meta(path)
        assert x == 256.0
        # y comes from bed_size_y or machine_depth; plate_y is not a recognised key
        # so y may be None here — that's acceptable
    finally:
        os.unlink(path)


def test_gcode_bambu_print_size_x():
    path = _write_gcode([
        "; print_size_x = 300",
    ])
    try:
        x, y = pfm._extract_gcode_meta(path)
        assert x == 300.0
    finally:
        os.unlink(path)


# ─────────────────────────────────────────────
# _extract_gcode_meta — no comments
# ─────────────────────────────────────────────

def test_gcode_no_slicer_comments():
    path = _write_gcode(["G28", "G1 X0 Y0", "M104 S200"])
    try:
        x, y = pfm._extract_gcode_meta(path)
        assert x is None
        assert y is None
    finally:
        os.unlink(path)


def test_gcode_beyond_100_lines_ignored():
    """Bed comments after line 100 should not be picked up."""
    lines = [f"G1 X{i}" for i in range(110)]
    lines[105] = "; bed_size_x = 999.00"
    path = _write_gcode(lines)
    try:
        x, y = pfm._extract_gcode_meta(path)
        assert x is None
    finally:
        os.unlink(path)


# ─────────────────────────────────────────────
# _extract_3mf_meta — KNOWN_PRINTER_BEDS lookup
# ─────────────────────────────────────────────

def test_3mf_bambu_machine_model_lookup():
    slice_info = 'machine_model = "Bambu Lab X1 Carbon"\n'
    path = _write_3mf({"Metadata/slice_info.config": slice_info})
    try:
        x, y = pfm._extract_3mf_meta(path)
        assert x == 256
        assert y == 256
    finally:
        os.unlink(path)


def test_3mf_bambu_p1s_lookup():
    slice_info = 'machine_model = "Bambu Lab P1S"\n'
    path = _write_3mf({"Metadata/slice_info.config": slice_info})
    try:
        x, y = pfm._extract_3mf_meta(path)
        assert x == 256
        assert y == 256
    finally:
        os.unlink(path)


def test_3mf_prusa_bed_shape():
    model_settings = "bed_shape = 0x0,250x0,250x210,0x210\n"
    path = _write_3mf({"Metadata/model_settings.config": model_settings})
    try:
        x, y = pfm._extract_3mf_meta(path)
        assert x == 250.0
        assert y == 210.0
    finally:
        os.unlink(path)


def test_3mf_no_metadata():
    """A .3mf with no recognisable metadata returns (None, None)."""
    path = _write_3mf({"3D/3dmodel.model": "<model/>"})
    try:
        x, y = pfm._extract_3mf_meta(path)
        assert x is None
        assert y is None
    finally:
        os.unlink(path)


# ─────────────────────────────────────────────
# extract_print_file_meta — public API
# ─────────────────────────────────────────────

def test_extract_meta_gcode_with_bed():
    path = _write_gcode([
        "; bed_size_x = 350.00",
        "; bed_size_y = 350.00",
    ])
    try:
        result = pfm.extract_print_file_meta(path, ".gcode")
        assert result["bed_x_mm"] == 350.0
        assert result["bed_y_mm"] == 350.0
        assert result["compatible_api_types"] == "moonraker,prusalink,elegoo"
    finally:
        os.unlink(path)


def test_extract_meta_gcode_no_comments():
    path = _write_gcode(["G28"])
    try:
        result = pfm.extract_print_file_meta(path, ".gcode")
        assert result["bed_x_mm"] is None
        assert result["bed_y_mm"] is None
        assert result["compatible_api_types"] == "moonraker,prusalink,elegoo"
    finally:
        os.unlink(path)


def test_extract_meta_3mf_returns_bambu_types():
    path = _write_3mf({"3D/3dmodel.model": "<model/>"})
    try:
        result = pfm.extract_print_file_meta(path, ".3mf")
        assert result["compatible_api_types"] == "bambu"
    finally:
        os.unlink(path)


def test_extract_meta_bgcode_returns_correct_types():
    """bgcode: no bed extraction (binary), but compatible_api_types is set."""
    # write a minimal binary file
    with tempfile.NamedTemporaryFile(suffix=".bgcode", delete=False) as f:
        f.write(b"\x00\x01\x02\x03")
        path = f.name
    try:
        result = pfm.extract_print_file_meta(path, ".bgcode")
        assert result["bed_x_mm"] is None
        assert result["bed_y_mm"] is None
        assert result["compatible_api_types"] == "moonraker,prusalink,elegoo"
    finally:
        os.unlink(path)


def test_extract_meta_does_not_raise_on_missing_file():
    """Extraction of a non-existent file must not raise — returns None values."""
    result = pfm.extract_print_file_meta("/nonexistent/file.gcode", ".gcode")
    assert result["bed_x_mm"] is None
    assert result["bed_y_mm"] is None
    assert result["compatible_api_types"] == "moonraker,prusalink,elegoo"


def test_extract_meta_does_not_raise_on_malformed_3mf():
    """A truncated/corrupted .3mf file must not raise."""
    with tempfile.NamedTemporaryFile(suffix=".3mf", delete=False) as f:
        f.write(b"not a zip file at all")
        path = f.name
    try:
        result = pfm.extract_print_file_meta(path, ".3mf")
        assert result["bed_x_mm"] is None
        assert result["compatible_api_types"] == "bambu"
    finally:
        os.unlink(path)


# ─────────────────────────────────────────────
# KNOWN_PRINTER_BEDS coverage
# ─────────────────────────────────────────────

def test_known_printer_beds_x1c():
    assert pfm.KNOWN_PRINTER_BEDS["x1c"] == (256, 256)


def test_known_printer_beds_ender3():
    assert pfm.KNOWN_PRINTER_BEDS["ender 3"] == (220, 220)


def test_lookup_known_bed_partial_match():
    result = pfm._lookup_known_bed("Bambu Lab X1 Carbon")
    assert result == (256, 256)


def test_lookup_known_bed_no_match():
    result = pfm._lookup_known_bed("Some Unknown Printer XYZ")
    assert result == (None, None)

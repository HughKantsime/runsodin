"""Integration tests for dispatch compatibility guardrails.

Tests run against a live API instance. Requires:
    BASE_URL, ADMIN_USERNAME, ADMIN_PASSWORD environment variables.

Run:
    pytest tests/test_dispatch_guardrails.py -v
"""

import io
import os
import uuid
import pytest
import requests

from helpers import login as _shared_login, auth_headers as _make_headers

BASE_URL = os.getenv("BASE_URL", "http://localhost:8000")
ADMIN_USERNAME = os.environ["ADMIN_USERNAME"]
ADMIN_PASSWORD = os.environ["ADMIN_PASSWORD"]

_TAG = f"guardrails_{uuid.uuid4().hex[:6]}"


# ─────────────────────────────────────────────
# Auth helpers
# ─────────────────────────────────────────────

@pytest.fixture(scope="module")
def admin_token():
    token = _shared_login(BASE_URL, ADMIN_USERNAME, ADMIN_PASSWORD)
    assert token, f"Admin login failed for {ADMIN_USERNAME}"
    return token


@pytest.fixture(scope="module")
def hdrs(admin_token):
    return _make_headers(admin_token)


# ─────────────────────────────────────────────
# Test: gcode upload stores bed metadata
# ─────────────────────────────────────────────

def test_gcode_upload_stores_bed_dimensions(hdrs):
    """Upload a .gcode with PrusaSlicer bed comments — verify print_files row has correct values."""
    gcode_content = "\n".join([
        "; generated by PrusaSlicer",
        "; bed_size_x = 350.00",
        "; bed_size_y = 350.00",
        "G28",
        "G1 X0 Y0 Z0.2",
    ])
    r = requests.post(
        f"{BASE_URL}/api/print-files/upload",
        headers=hdrs,
        files={"file": (f"test_{_TAG}.gcode", io.BytesIO(gcode_content.encode()), "text/plain")},
        timeout=30,
    )
    assert r.status_code == 200, f"Upload failed: {r.text}"
    data = r.json()
    assert data.get("bed_x_mm") == 350.0, f"Expected bed_x_mm=350.0, got {data.get('bed_x_mm')}"
    assert data.get("bed_y_mm") == 350.0, f"Expected bed_y_mm=350.0, got {data.get('bed_y_mm')}"
    assert "moonraker" in (data.get("compatible_api_types") or ""), \
        f"Expected moonraker in compatible_api_types, got {data.get('compatible_api_types')}"
    return data["id"]


def test_gcode_upload_no_comments_returns_null_bed(hdrs):
    """Upload a .gcode with no slicer comments — bed dims should be null, no error."""
    gcode_content = "G28\nG1 X0 Y0\nM104 S200\n"
    r = requests.post(
        f"{BASE_URL}/api/print-files/upload",
        headers=hdrs,
        files={"file": (f"nocomments_{_TAG}.gcode", io.BytesIO(gcode_content.encode()), "text/plain")},
        timeout=30,
    )
    assert r.status_code == 200, f"Upload failed: {r.text}"
    data = r.json()
    assert data.get("bed_x_mm") is None
    assert data.get("bed_y_mm") is None
    assert data.get("compatible_api_types") == "moonraker,prusalink,elegoo"


# ─────────────────────────────────────────────
# Test: printer API returns bed fields
# ─────────────────────────────────────────────

def test_create_printer_with_bed_dims_and_retrieve(hdrs):
    """Create a printer with bed_x_mm/bed_y_mm — verify GET returns them."""
    printer_data = {
        "name": f"test_printer_{_TAG}",
        "model": "Ender 3",
        "api_type": "moonraker",
        "api_host": "192.168.99.250",
        "bed_x_mm": 220,
        "bed_y_mm": 220,
    }
    r = requests.post(f"{BASE_URL}/api/printers", headers=hdrs, json=printer_data, timeout=10)
    assert r.status_code in (200, 201), f"Create printer failed: {r.text}"
    printer_id = r.json()["id"]

    try:
        r2 = requests.get(f"{BASE_URL}/api/printers/{printer_id}", headers=hdrs, timeout=10)
        assert r2.status_code == 200
        p = r2.json()
        assert p.get("bed_x_mm") == 220, f"Expected bed_x_mm=220, got {p.get('bed_x_mm')}"
        assert p.get("bed_y_mm") == 220, f"Expected bed_y_mm=220, got {p.get('bed_y_mm')}"
    finally:
        requests.delete(f"{BASE_URL}/api/printers/{printer_id}", headers=hdrs, timeout=10)


# ─────────────────────────────────────────────
# Test: dispatch bed-size guard blocks oversized job
# ─────────────────────────────────────────────

def test_dispatch_blocked_by_bed_size_mismatch(hdrs):
    """Dispatch a 350mm-sliced file to a 220mm printer — expect HTTP 400 with bed mismatch message."""
    # 1. Upload the oversized gcode
    gcode_content = "\n".join([
        "; bed_size_x = 350.00",
        "; bed_size_y = 350.00",
        "G28",
    ])
    r = requests.post(
        f"{BASE_URL}/api/print-files/upload",
        headers=hdrs,
        files={"file": (f"oversize_{_TAG}.gcode", io.BytesIO(gcode_content.encode()), "text/plain")},
        timeout=30,
    )
    assert r.status_code == 200
    upload = r.json()
    model_id = upload["model_id"]

    # 2. Create a small-bed printer
    printer_data = {
        "name": f"small_bed_{_TAG}",
        "model": "Ender 3",
        "api_type": "moonraker",
        "api_host": "192.168.99.251",
        "bed_x_mm": 220,
        "bed_y_mm": 220,
    }
    r2 = requests.post(f"{BASE_URL}/api/printers", headers=hdrs, json=printer_data, timeout=10)
    assert r2.status_code in (200, 201), r2.text
    printer_id = r2.json()["id"]

    try:
        # 3. Create a job linking the model to the small-bed printer
        job_data = {
            "item_name": f"oversize_job_{_TAG}",
            "model_id": model_id,
            "printer_id": printer_id,
            "priority": 5,
            "quantity": 1,
            "status": "scheduled",
        }
        r3 = requests.post(f"{BASE_URL}/api/jobs", headers=hdrs, json=job_data, timeout=10)
        assert r3.status_code in (200, 201), r3.text
        job_id = r3.json()["id"]

        # Set job status to scheduled so dispatch doesn't reject it on status grounds
        requests.patch(
            f"{BASE_URL}/api/jobs/{job_id}",
            headers=hdrs,
            json={"status": "scheduled"},
            timeout=10,
        )

        try:
            # 4. Attempt dispatch — should be blocked
            r4 = requests.post(
                f"{BASE_URL}/api/jobs/{job_id}/dispatch",
                headers=hdrs,
                timeout=30,
            )
            # Expect 400; if the printer has no real API, the error may differ —
            # but the bed-size check fires before network calls, so we should get 400
            # with the bed mismatch message (or at minimum the dispatch returns an error)
            if r4.status_code == 400:
                detail = r4.json().get("detail", "")
                assert "sliced for" in detail.lower() or "bed" in detail.lower(), \
                    f"Expected bed mismatch message, got: {detail}"
            else:
                # Some environments may return 400 at different points — accept any non-2xx
                assert r4.status_code != 200, \
                    f"Expected dispatch to fail for oversized file, but got 200"
        finally:
            requests.delete(f"{BASE_URL}/api/jobs/{job_id}", headers=hdrs, timeout=10)
    finally:
        requests.delete(f"{BASE_URL}/api/printers/{printer_id}", headers=hdrs, timeout=10)


# ─────────────────────────────────────────────
# Test: dispatch compatible_api_types guard
# ─────────────────────────────────────────────

def test_dispatch_blocked_by_api_type_mismatch(hdrs):
    """Dispatch a 3mf to a moonraker printer — should return 400 (existing .3mf guard still works)."""
    # Build a minimal valid .3mf (zip with required structure)
    import zipfile
    import tempfile

    with tempfile.NamedTemporaryFile(suffix=".3mf", delete=False) as tf:
        tmp_path = tf.name

    try:
        with zipfile.ZipFile(tmp_path, "w") as zf:
            zf.writestr("3D/3dmodel.model", "<model unit='millimeter' xml:lang='en-US'><resources/><build/></model>")
            zf.writestr("[Content_Types].xml", '<?xml version="1.0"?><Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types"><Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/><Default Extension="model" ContentType="application/vnd.ms-package.3dmanufacturing-3dmodel+xml"/></Types>')
            zf.writestr("_rels/.rels", '<?xml version="1.0"?><Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships"><Relationship Target="/3D/3dmodel.model" Id="rel0" Type="http://schemas.microsoft.com/3dmanufacturing/2013/01/3dmodel"/></Relationships>')

        with open(tmp_path, "rb") as f:
            r = requests.post(
                f"{BASE_URL}/api/print-files/upload",
                headers=hdrs,
                files={"file": (f"test_{_TAG}.3mf", f, "application/octet-stream")},
                timeout=30,
            )
    finally:
        os.unlink(tmp_path)

    # The 3mf parse may fail on this minimal file — that's OK, we mainly want to verify
    # the upload doesn't crash and the compatible_api_types guard works when it can.
    # If upload succeeds, verify it returns compatible_api_types=bambu
    if r.status_code == 200:
        data = r.json()
        assert data.get("compatible_api_types") == "bambu", \
            f"Expected compatible_api_types=bambu for .3mf, got {data.get('compatible_api_types')}"


# ─────────────────────────────────────────────
# Test: dispatch null bed — soft fail (no error)
# ─────────────────────────────────────────────

def test_dispatch_null_bed_does_not_trigger_bed_guard(hdrs):
    """Upload a gcode with no bed comments; dispatch should not fail with a bed error."""
    gcode_content = "G28\nG1 X0 Y0\n"
    r = requests.post(
        f"{BASE_URL}/api/print-files/upload",
        headers=hdrs,
        files={"file": (f"nullbed_{_TAG}.gcode", io.BytesIO(gcode_content.encode()), "text/plain")},
        timeout=30,
    )
    assert r.status_code == 200
    upload = r.json()
    assert upload.get("bed_x_mm") is None

    model_id = upload["model_id"]

    # Create a printer with known bed dims
    printer_data = {
        "name": f"nullbed_printer_{_TAG}",
        "model": "Ender 3",
        "api_type": "moonraker",
        "api_host": "192.168.99.252",
        "bed_x_mm": 220,
        "bed_y_mm": 220,
    }
    r2 = requests.post(f"{BASE_URL}/api/printers", headers=hdrs, json=printer_data, timeout=10)
    assert r2.status_code in (200, 201), r2.text
    printer_id = r2.json()["id"]

    try:
        job_data = {
            "item_name": f"nullbed_job_{_TAG}",
            "model_id": model_id,
            "printer_id": printer_id,
            "priority": 5,
            "quantity": 1,
        }
        r3 = requests.post(f"{BASE_URL}/api/jobs", headers=hdrs, json=job_data, timeout=10)
        assert r3.status_code in (200, 201), r3.text
        job_id = r3.json()["id"]

        requests.patch(
            f"{BASE_URL}/api/jobs/{job_id}",
            headers=hdrs,
            json={"status": "scheduled"},
            timeout=10,
        )

        try:
            r4 = requests.post(
                f"{BASE_URL}/api/jobs/{job_id}/dispatch",
                headers=hdrs,
                timeout=30,
            )
            # May fail for network reasons (no real printer) but must NOT be a bed error
            if r4.status_code == 400:
                detail = r4.json().get("detail", "")
                assert "sliced for" not in detail.lower(), \
                    f"Bed guard should not fire when bed_x_mm is NULL. Got: {detail}"
        finally:
            requests.delete(f"{BASE_URL}/api/jobs/{job_id}", headers=hdrs, timeout=10)
    finally:
        requests.delete(f"{BASE_URL}/api/printers/{printer_id}", headers=hdrs, timeout=10)
